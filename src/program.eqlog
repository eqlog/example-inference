pred VariableShadowing();
pred ConflictingTypes();

// # The AST, encoded algebraically/relationally.
type ModuleNode;

type TypeNode;
type OptTypeNode;

type ExprNode;
type ExprListNode;

type StmtNode;
type StmtListNode;

type FunctionNode;

type Var;
type StringLiteral;
type NumberLiteral;

type ArgListNode;

// Module(node, top_lvl_stmts)
pred Module(ModuleNode, StmtListNode);

pred VoidTypeNode(TypeNode);
pred BooleanTypeNode(TypeNode);
pred NumberTypeNode(TypeNode);
pred StringTypeNode(TypeNode);
// FunctionTypeNode(node, domain, codomain)
pred FunctionTypeNode(TypeNode, ArgListNode, TypeNode);

pred VariableExprNode(ExprNode, Var);
pred VoidExprNode(ExprNode);
pred FalseExprNode(ExprNode);
pred TrueExprNode(ExprNode);
pred StringLiteralExprNode(ExprNode, StringLiteral);
pred NumberLiteralExprNode(ExprNode, NumberLiteral);
pred EqualsExprNode(ExprNode, ExprNode, ExprNode);
// AppExprNode(node, func, args)
pred AppExprNode(ExprNode, ExprNode, ExprListNode);
pred FunctionExprNode(ExprNode, FunctionNode);

pred ExprStmtNode(StmtNode, ExprNode);
// LetStmtNode(node, var, initial_value)
pred LetStmtNode(StmtNode, Var, OptTypeNode, ExprNode);
// ReturnStmtNode(node, return_value)
pred ReturnStmtNode(StmtNode, ExprNode);
pred ReturnVoidStmtNode(StmtNode);
pred FunctionStmtNode(StmtNode, FunctionNode);
// IfStmtNode(node, condition, true_branch, false_branch)
pred IfStmtNode(StmtNode, ExprNode, StmtListNode, StmtListNode);
// WhileStmtNode(node, condition, body)
pred WhileStmtNode(StmtNode, ExprNode, StmtListNode);

// Function(node, function_name, domain, codomain, body)
pred Function(FunctionNode, Var, ArgListNode, OptTypeNode, StmtListNode);

// ## <Sort>NodeList operators.
pred NilExprListNode(ExprListNode);
pred ConsExprListNode(ExprListNode, ExprNode, ExprListNode);

pred NilStmtListNode(StmtListNode);
pred ConsStmtListNode(StmtListNode, StmtNode, StmtListNode);

// ## ArgListNode operators.
pred NilArgListNode(ArgListNode);
pred ConsArgListNode(ArgListNode, Var, OptTypeNode, ArgListNode);

// ## OptTypeNode operators.
pred NoneOptTypeNode(OptTypeNode);
pred SomeOptTypeNode(OptTypeNode, TypeNode);


// # Semantic types.

// ## Simple (i.e. mono) types.
type Type;
type TypeList;

// ## Semantic type operators.
func VoidType() -> Type;
func BooleanType() -> Type;
func NumberType() -> Type;
func StringType() -> Type;
// FunctionType(node, domain, codomain)
func FunctionType(TypeList, Type) -> Type;
// Inverses to FunctionType:
// - DomainTypes(FunctionType(domain, _)) = domain
// - CodomainType(FunctionType(_, codomain)) = codomain
func DomainTypes(Type) -> TypeList;
func CodomainType(Type) -> Type;

rule {
  if DomainTypes(tau)!;
  then CodomainType(tau)!;
}
rule {
  if CodomainType(tau)!;
  then DomainTypes(tau)!;
}
rule {
  if kappa = FunctionType(sigmas, tau);
  then DomainTypes(kappa) = sigmas;
  then CodomainType(kappa) = tau;
}
rule {
  if sigmas = DomainTypes(kappa);
  if tau = CodomainType(kappa);
  then FunctionType(sigmas, tau) = kappa;
}

// ## TypeList operators.
// We're equating TypeList elements sometimes. In well-typed programs, this is only possible if the
// type lists have the same length and are made up of the same Types.
func NilTypeList() -> TypeList;
func ConsTypeList(Type, TypeList) -> TypeList;
rule {
  if NilTypeList() = ConsTypeList(_, _);
  then ConflictingTypes();
}
rule {
  if ConsTypeList(head_0, tail_0) = ConsTypeList(head_1, tail_1);
  then head_0 = head_1;
  then tail_0 = tail_1;
}

// ## Joint injectivity of type operators.
rule {
  if VoidType() = BooleanType();
  then ConflictingTypes();
}
rule {
  if VoidType() = NumberType();
  then ConflictingTypes();
}
rule {
  if VoidType() = StringType();
  then ConflictingTypes();
}
rule {
  if VoidType() = FunctionType(_, _);
  then ConflictingTypes();
}

rule {
  if BooleanType() = NumberType();
  then ConflictingTypes();
}
rule {
  if BooleanType() = StringType();
  then ConflictingTypes();
}
rule {
  if BooleanType() = FunctionType(_, _);
  then ConflictingTypes();
}

rule {
  if NumberType() = StringType();
  then ConflictingTypes();
}
rule {
  if NumberType() = FunctionType(_, _);
  then ConflictingTypes();
}

rule {
  if StringType() = FunctionType(_, _);
  then ConflictingTypes();
}

rule {
  if FunctionType(domain_0, codomain_0) = FunctionType(domain_1, codomain_1);
  then domain_0 = domain_1;
  then codomain_0 = codomain_1;
}

// ## Functions assigning to node elements their corresponding semantic Type elements.
func SemanticType(TypeNode) -> Type;
func SemanticOptType(OptTypeNode) -> Type;
func SemanticArgTypes(ArgListNode) -> TypeList;

// The types of expressions and function literals:
func ExprType(ExprNode) -> Type;
func ExprTypes(ExprListNode) -> TypeList;
func FunctionNodeType(FunctionNode) -> Type;

// All of the functions into Type that we've just declared are total.
rule {
  if tn: TypeNode;
  then SemanticType(tn)!;
}
rule {
  if otn: OptTypeNode;
  then SemanticOptType(otn)!;
}
rule {
  if agn: ArgListNode;
  then SemanticArgTypes(agn)!;
}
rule {
  if en: ExprNode;
  then ExprType(en)!;
}
rule {
  if eln: ExprListNode;
  then ExprTypes(eln)!;
}
rule {
  if fcn: FunctionNode;
  then FunctionNodeType(fcn)!;
}

// Since SemanticType is total, these rules will fire for all TypeNodes.
rule {
  if VoidTypeNode(tn);
  if sigma = SemanticType(tn);
  then VoidType() = sigma;
}
rule {
  if BooleanTypeNode(tn);
  if sigma = SemanticType(tn);
  then BooleanType() = sigma;
}
rule {
  if NumberTypeNode(tn);
  if sigma = SemanticType(tn);
  then NumberType() = sigma;
}
rule {
  if StringTypeNode(tn);
  if sigma = SemanticType(tn);
  then StringType() = sigma;
}

// Other axioms assert that SemanticArgTypes and SemanticType are total functions, so this rule
// will fire for al FunctionTypeNodes.
rule {
  if FunctionTypeNode(tn, args, codomain);
  if dom_types = SemanticArgTypes(args);
  if cod_type = SemanticType(codomain);
  if function_type = SemanticType(tn);
  then FunctionType(dom_types, cod_type) = function_type;
}

// SemanticOptType is total, but only for SomeOptTypeNode elements does it have a determined type.
// If no other rules apply, it will be an opaque Type element determined only by the OptTypeNode
// element.
rule {
  if SomeOptTypeNode(otn, tn);
  if sigma = SemanticType(tn);
  then SemanticOptType(otn) = sigma;
}

rule {
  if NilArgListNode(al);
  if semantic_types = SemanticArgTypes(al);
  then NilTypeList() = semantic_types;
}
rule {
  if ConsArgListNode(al, _, head_type, tail);
  if semantic_head = SemanticOptType(head_type);
  if semantic_tail = SemanticArgTypes(tail);
  if semantic_types = SemanticArgTypes(al);
  then semantic_types = ConsTypeList(semantic_head, semantic_tail);
}

// ## Determined types, i.e. those that do not contain unsolved type variables.
//
// In well-formed programs, every type should be determined.
//
// Without polymorphism, for example the following program contains an
// undetermined type:
//
//   function foo(x) {}
//
// Here the type of `x` is not determined. Applying the function at least once on an argument with
// determined type will determine the argument type of `foo` though, for example if we add the
// statement `foo(5);`
//
// With polymorphism the above example doesn't work, since `foo` will have type `forall a. a ->
// unit`. However, unsolved type variables remain a problem because we require variables introduced
// using `let` to have a mono/simple type. Consider the following example program:
//
//   function foo() {
//     return foo();
//   }
//
//   let x = foo();
//
// Here `foo`  has type `forall a. () -> a`. Thus, `x` must  be simple type, but it can be any
// simple type: The type of `x` is not determined.

pred DeterminedType(Type);
pred DeterminedTypes(TypeList);

// A type list is determined if all of the types it contains are determined.
rule {
  if sigmas = NilTypeList();
  then DeterminedTypes(sigmas);
}
rule {
  if sigmas = ConsTypeList(head, tail);
  if DeterminedType(head);
  if DeterminedTypes(tail);
  then DeterminedTypes(sigmas);
}

rule {
  if sigma = VoidType();
  then DeterminedType(sigma);
}
rule {
  if sigma = BooleanType();
  then DeterminedType(sigma);
}
rule {
  if sigma = NumberType();
  then DeterminedType(sigma);
}
rule {
  if sigma = StringType();
  then DeterminedType(sigma);
}
rule {
  if sigma = FunctionType(dom, cod);
  if DeterminedTypes(dom);
  if DeterminedType(cod);
  then DeterminedType(sigma);
}
rule {
  if sigmas = DomainTypes(kappa);
  if DeterminedType(kappa);
  then DeterminedTypes(sigmas);
}
rule {
  if tau = CodomainType(kappa);
  if DeterminedType(kappa);
  then DeterminedType(tau);
}

rule {
  if ConsArgListNode(_, _, otn, _);
  if t = SemanticOptType(otn);
  then DeterminedType(t);
}
rule {
  if Function(_, _, _, codomain_otn, _);
  if t = SemanticOptType(codomain_otn);
  then DeterminedType(t);
}

// ## Well-founded types
//
// Consider the following (invalid) function definition:
//
//   function foo (x) {
//       x(x);
//   }
//
// If a denotes the type of x, then a must be equal to the function type a => a, which is
// unsatisfiable. To issue an error in cases such as this one, we introduce a binary predicate
// SmallerType such that SmallerType(sigma, tau) holds if and only if sigma is structurally
// strictly smaller than tau.  If we find that a type must be structurally smaller than itself,
// then we generate an error.

pred SmallerType(Type, Type);
rule {
  if SmallerType(sigma, tau);
  if SmallerType(tau, kappa);
  then SmallerType(sigma, kappa);
}

rule {
  if SmallerType(sigma, sigma);
  then ConflictingTypes();
}

// SmallerTypes(sigmas, tau) <=> forall sigma in sigma. SmallerType(sigma, tau)
pred SmallerTypes(TypeList, Type);
rule {
  if sigmas = NilTypeList();
  if tau: Type;
  then SmallerTypes(sigmas, tau);
}
rule {
  if SmallerTypes(ConsTypeList(head, tail), tau);
  then SmallerType(head, tau);
  then SmallerTypes(tail, tau);
}
rule {
  if SmallerType(head, tau);
  if SmallerTypes(tail, tau);
  if sigmas = ConsTypeList(head, tail);
  then SmallerTypes(sigmas, tau);
}

// All domain types and the codomain of a function type are smaller than the function type.
rule {
  if kappa = FunctionType(sigmas, tau);
  then SmallerTypes(sigmas, kappa);
  then SmallerType(tau, kappa);
}

// # Type contexts.
type TypeContext;

pred TypeInContext(Type, TypeContext);
pred TypesInContext(TypeList, TypeContext);

rule {
  if gamma: TypeContext;
  if NilTypeList()!;
  then TypesInContext(NilTypeList(), gamma);
}
rule {
  if sigmas = ConsTypeList(sigmas_head, sigmas_tail);
  if TypeInContext(sigmas_head, gamma);
  if TypesInContext(sigmas_tail, gamma);
  then TypesInContext(sigmas, gamma);
}

rule {
  if TypesInContext(ConsTypeList(head, tail), gamma);
  then TypeInContext(head, gamma);
  then TypesInContext(tail, gamma);
}

pred ContextExtension(TypeContext, TypeContext);
rule {
  if ContextExtension(gamma_0, gamma_1);
  if TypeInContext(sigma, gamma_0);
  then TypeInContext(sigma, gamma_1);
}

// ## Type contexts are closed under type formers and their inverses.
rule {
  if TypeInContext(FunctionType(dom, cod), gamma);
  then TypesInContext(dom, gamma);
  then TypeInContext(cod, gamma);
}
rule {
  if kappa = FunctionType(dom, cod);
  if TypesInContext(dom, gamma);
  if TypeInContext(cod, gamma);
  then TypeInContext(kappa, gamma);
}

rule {
  if gamma: TypeContext;
  if sigma = VoidType();
  then TypeInContext(sigma, gamma);
}
rule {
  if gamma: TypeContext;
  if sigma = BooleanType();
  then TypeInContext(sigma, gamma);
}
rule {
  if gamma: TypeContext;
  if sigma = NumberType();
  then TypeInContext(sigma, gamma);
}
rule {
  if gamma: TypeContext;
  if sigma = StringType();
  then TypeInContext(sigma, gamma);
}

// ## The type contexts associated with expressions and statements.
func ModuleTypeContext(ModuleNode) -> TypeContext;
func FunctionTypeContext(FunctionNode) -> TypeContext;
func ArgListContext(ArgListNode) -> TypeContext;
func StmtTypeContext(StmtNode) -> TypeContext;
func StmtsTypeContext(StmtListNode) -> TypeContext;
func ExprTypeContext(ExprNode) -> TypeContext;
func ExprsTypeContext(ExprListNode) -> TypeContext;

rule {
  if mn: ModuleNode;
  then ModuleTypeContext(mn)!;
}
rule {
  if fn: FunctionNode;
  then FunctionTypeContext(fn)!;
}
rule {
  if args: ArgListNode;
  then ArgListContext(args)!;
}
rule {
  if stmt: StmtNode;
  then StmtTypeContext(stmt)!;
}
rule {
  if stmts: StmtListNode;
  then StmtsTypeContext(stmts)!;
}
rule {
  if expr: ExprNode;
  then ExprTypeContext(expr)!;
}
rule {
  if exprs: ExprListNode;
  then ExprsTypeContext(exprs)!;
}

// ## Populating the TypeInContext predicate.

// Forward declarations.
type GeneralType;
func VarTypeInArgList(Var, ArgListNode) -> GeneralType;
func MonoType(Type) -> GeneralType;

// The type of a function argument is in the context of the arg list of the function.
rule {
  if ConsArgListNode(arg_list, _, head_ty_node, _);
  if ctx = ArgListContext(arg_list);
  if head_ty = SemanticOptType(head_ty_node);
  then TypeInContext(head_ty, ctx);
}

// Relate type contexts of node lists with the type contexts of individual nodes in the lists.
rule {
  if ConsArgListNode(al, _, _, tail);
  if ArgListContext(al) = ctx;
  then ArgListContext(tail) = ctx;
}
rule {
  if ConsStmtListNode(stmts, head, tail);
  if StmtsTypeContext(stmts) = ctx;
  then StmtTypeContext(head) = ctx;
  then StmtsTypeContext(tail) = ctx;
}
rule {
  if ConsExprListNode(stmts, head, tail);
  if ExprsTypeContext(stmts) = ctx;
  then ExprTypeContext(head) = ctx;
  then ExprsTypeContext(tail) = ctx;
}

// Module type contexts propagate into top level statements.
rule {
  if Module(mn, stmts);
  if ctx = ModuleTypeContext(mn);
  then StmtsTypeContext(stmts) = ctx;
}

// Function type contexts propagate into bodies.
rule {
  if Function(fn, _, arg_list, _, stmts);
  if ctx = FunctionTypeContext(fn);
  then StmtsTypeContext(stmts) = ctx;
  then ArgListContext(arg_list) = ctx;
}

// ## Propagate type contexts through statements.
rule {
  if ExprStmtNode(stmt, expr);
  if ctx = StmtTypeContext(stmt);
  then ExprTypeContext(expr) = ctx;
}
rule {
  if LetStmtNode(stmt, _, _, expr);
  if ctx = StmtTypeContext(stmt);
  then ExprTypeContext(expr) = ctx;
}
rule {
  if ReturnStmtNode(stmt, expr);
  if ctx = StmtTypeContext(stmt);
  then ExprTypeContext(expr) = ctx;
}
rule {
  if FunctionStmtNode(stmt, func_node);
  if ambient_ctx = StmtTypeContext(stmt);
  if func_ctx = FunctionTypeContext(func_node);
  then ContextExtension(ambient_ctx, func_ctx);
}
rule {
  if IfStmtNode(stmt, cond, true_branch, false_branch);
  if stmt_ctx = StmtTypeContext(stmt);
  if cond_ctx = ExprTypeContext(cond);
  if true_branch_ctx = StmtsTypeContext(true_branch);
  if false_branch_ctx = StmtsTypeContext(false_branch);
  then stmt_ctx = cond_ctx;
  then cond_ctx = true_branch_ctx;
  then true_branch_ctx = false_branch_ctx;
}
rule {
  if WhileStmtNode(stmt, cond, body);
  if stmt_ctx = StmtTypeContext(stmt);
  if cond_ctx = ExprTypeContext(cond);
  if body_ctx = StmtsTypeContext(body);
  then stmt_ctx = cond_ctx;
  then cond_ctx = body_ctx;
}

// ## Propagate type contexts through expressions.

rule {
  if EqualsExprNode(expr, lhs, rhs);
  if expr_ctx = ExprTypeContext(expr);
  if lhs_ctx = ExprTypeContext(lhs);
  if rhs_ctx = ExprTypeContext(rhs);
  then expr_ctx = lhs_ctx;
  then lhs_ctx = rhs_ctx;
}

rule {
  if AppExprNode(expr, fn_expr, arg_exprs);
  if expr_ctx = ExprTypeContext(expr);
  if fn_ctx = ExprTypeContext(fn_expr);
  if args_ctx = ExprsTypeContext(arg_exprs);
  then expr_ctx = fn_ctx;
  then fn_ctx = args_ctx;
}

rule {
  if FunctionExprNode(expr, func_node);
  if expr_ctx = ExprTypeContext(expr);
  if func_ctx = FunctionTypeContext(func_node);
  then ContextExtension(expr_ctx, func_ctx);
}

// ## Type instantiation.
type Instantiation;

func InstantiationTarget(Instantiation) -> TypeContext;

func Instantiate(Instantiation, Type) -> Type;
func InstantiateList(Instantiation, TypeList) -> TypeList;

rule {
  if instances = InstantiateList(_, NilTypeList());
  then instances = NilTypeList();
}
rule {
  if InstantiateList(instance, ConsTypeList(head, tail))!;
  then Instantiate(instance, head)!;
  then InstantiateList(instance, tail)!;
}

rule {
  if head_instance = Instantiate(instance, head);
  if tail_instance = InstantiateList(instance, tail);
  if instances = InstantiateList(instance, ConsTypeList(head, tail));
  then instances = ConsTypeList(head_instance, tail_instance);
}

// ## Instantiation laws.
rule {
  if tau = Instantiate(instance, sigma);
  if TypeInContext(sigma, InstantiationTarget(instance));
  then sigma = tau;
}

rule {
  if instance_void = Instantiate(_, VoidType());
  then VoidType() = instance_void;
}
rule {
  if instance_boolean = Instantiate(_, BooleanType());
  then BooleanType() = instance_boolean;
}
rule {
  if instance_number = Instantiate(_, NumberType());
  then NumberType() = instance_number;
}
rule {
  if instance_string = Instantiate(_, StringType());
  then StringType() = instance_string;
}

rule {
  if Instantiate(instance, FunctionType(dom, cod))!;
  then InstantiateList(instance, dom)!;
  then Instantiate(instance, cod)!;
}
rule {
  if dom_instances = InstantiateList(instance, dom);
  if cod_instance = Instantiate(instance, cod);
  if func_instance = Instantiate(instance, FunctionType(dom, cod));
  then FunctionType(dom_instances, cod_instance) = func_instance;
}


// # Variable resolution.

// For each node kind X in which variables matter, we introduce a function
//
//   VarTypeInX : Var * X -> GeneralType
//
// and add axioms such that VarTypeInX(var, n) = sigma holds iff var is considered to be in scope
// for node n and has type sigma. That var must be in scope for n means that var must have been
// introduced *before* n; it is not sufficient for n to introduce the variable.
//
// For X = StmtListNode and X = ArgListNode, note that if n = ConsX(head, tail), then head appears
// before tail in source code. For example, if body is the StmtListNode representing the body of a
// function, then none of the variables introduced in the body will be in scope for body. Instead,
// all of those variables are in scope at the NilStmtListNode of body. Similarly, if args is the
// ArgListNode of a function definition, then the variables listed in args are only in scope for the
// NilArgListNode at the end of args.

func PolyType(Type) -> GeneralType;
// Declared earlier:
// Func MonoType : Type -> GeneralType;
rule {
  if sigma: Type;
  then MonoType(sigma)!;
}

func VarTypeInStmts(Var, StmtListNode) -> GeneralType;
func VarTypeInFunction(Var, FunctionNode) -> GeneralType;
// Declared earlier:
// Func VarTypeInArgList : Var * ArgListNode -> GeneralType;
func VarTypeInExpr(Var, ExprNode) -> GeneralType;
func VarTypeInExprs(Var, ExprListNode) -> GeneralType;

// ## Base cases: Nodes that introduce variables

// Every let statements introduces a variable.
rule {
  if ConsStmtListNode(_, head, tail);
  if LetStmtNode(head, var, ty_annot, expr);
  if ty = SemanticOptType(ty_annot);
  if expr_type = ExprType(expr);
  if mono_expr_type = MonoType(expr_type);
  then expr_type = ty;
  then VarTypeInStmts(var, tail) = mono_expr_type;
}

// Every function statement introduces a variable for statements occuring after the function
// statement.
rule {
  if ConsStmtListNode(_, head, _);
  if FunctionStmtNode(head, func_node);
  if Function(func_node, _, _, _, _);
  then PolyType(FunctionNodeType(func_node))!;
}
rule {
  if ConsStmtListNode(_, head, tail);
  if FunctionStmtNode(head, func_node);
  if Function(func_node, var, _, _, _);
  if ty = PolyType(FunctionNodeType(func_node));
  then VarTypeInStmts(var, tail) = ty;
}

// Every function node introduces the name of the function in the ArgListNode of the function (and
// hence, by the propagation axioms below, also in the body of the function).
rule {
  if Function(func_node, var, arg, _, _);
  if ty = MonoType(FunctionNodeType(func_node));
  then VarTypeInArgList(var, arg) = ty;
}

// Every function argument introduces a variable.
rule {
  if ConsArgListNode(_, var, otn, tail);
  if ty = MonoType(SemanticOptType(otn));
  then VarTypeInArgList(var, tail) = ty;
}

// ## Errors due to multiple introductions of the same variable
//
// For each base node case that introduces a variable, it is an error if the variable is already in
// scope before the node.

rule {
  if ConsStmtListNode(stmts, head, _);
  if LetStmtNode(head, var, _, _);
  if VarTypeInStmts(var, stmts)!;
  then VariableShadowing();
}
rule {
  if FunctionStmtNode(head, func_node);
  if Function(func_node, var, _, _, _);
  if VarTypeInStmts(var, stmts)!;
  if ConsStmtListNode(stmts, head, _);
  then VariableShadowing();
}
rule {
  if Function(func_node, var, _, _, _);
  if VarTypeInFunction(var, func_node)!;
  then VariableShadowing();
}
rule {
  if ConsArgListNode(al, var, _, _);
  if VarTypeInArgList(var, al)!;
  then VariableShadowing();
}

// ## Propagation of variables through lists
//
// If a variable is in scope for ConsX(head, tail), then it should also be in scope for tail.

rule {
  if ConsStmtListNode(stmts, _, tail);
  if sigma = VarTypeInStmts(var, stmts);
  then VarTypeInStmts(var, tail) = sigma;
}
rule {
  if ConsArgListNode(al, _, _, tail);
  if sigma = VarTypeInArgList(var, al);
  then VarTypeInArgList(var, tail) = sigma;
}
rule {
  if ConsExprListNode(exprs, head, tail);
  if sigma = VarTypeInExprs(var, exprs);
  then VarTypeInExpr(var, head) = sigma;
  then VarTypeInExprs(var, tail) = sigma;
}

// ## Propagating variables through nodes
//
// If a variable is in scope before some node n, then it is usually also in scope at all nodes that
// make up n.

// ### Propagating into function bodies
//
// Apart from the variables propagated from outside of the scope of a function literal (which will
// be propagated later), the variables accessible in a function body are as follows:
// 1. The variables defined in the ambient scope of the function definition.
// 2. The name of the function (for recursive calls).
// 3. Function arguments.
//
// We propagate 1 and 2 into 3, and 3 into the function body.

// Propagate ambient variables into arg lists.
rule {
  if Function(func_node, _, args, _, _);
  if sigma = VarTypeInFunction(var, func_node);
  then VarTypeInArgList(var, args) = sigma;
}

// By the "end" of a node list l we mean the unique nil node from which l can be obtained by
// repeated consing. We need access to the end of an ArgListNode so that we know the full set of
// variables introduced in that arg list.
pred ArgListEnd(ArgListNode, ArgListNode);
rule {
  if NilArgListNode(arg_list);
  then ArgListEnd(arg_list, arg_list);
}
rule {
  if ConsArgListNode(arg_list, _, _, tail);
  if ArgListEnd(tail, end);
  then ArgListEnd(arg_list, end);
}

// Propagate variables from the arg list into the body.
rule {
  if Function(_, _, args, _, body);
  if ArgListEnd(args, args_end);
  if sigma = VarTypeInArgList(var, args_end);
  then VarTypeInStmts(var, body) = sigma;
}

// ### Propagating variables through statements

// If a variable is in scope in the statement that defines a function, then the variable is also in
// scope of the ArgListNode of that function (which then means that it is in scope for the body).
rule {
  if ConsStmtListNode(stmts, head, _);
  if FunctionStmtNode(head, func_node);
  if sigma = VarTypeInStmts(var, stmts);
  then VarTypeInFunction(var, func_node) = sigma;
}

// Propagate variables through if statements.
rule {
  if ConsStmtListNode(stmts, head, _);
  if IfStmtNode(head, cond, true_branch, false_branch);
  if sigma = VarTypeInStmts(var, stmts);
  then VarTypeInExpr(var, cond) = sigma;
  then VarTypeInStmts(var, true_branch) = sigma;
  then VarTypeInStmts(var, false_branch) = sigma;
}

// Propagate variables through while statements.
rule {
  if ConsStmtListNode(stmts, head, _);
  if WhileStmtNode(head, cond, body);
  if sigma = VarTypeInStmts(var, stmts);
  then VarTypeInStmts(var, body) = sigma;
  then VarTypeInExpr(var, cond) = sigma;
}

// Propagate variables through expression statements.
rule {
  if ConsStmtListNode(stmts, head, _);
  if ExprStmtNode(head, expr);
  if sigma = VarTypeInStmts(var, stmts);
  then VarTypeInExpr(var, expr) = sigma;
}

// Propagate previously defined variables through let statements into initializer expressions.
rule {
  if ConsStmtListNode(stmts, head, _);
  if LetStmtNode(head, _, _, expr);
  if sigma = VarTypeInStmts(var, stmts);
  then VarTypeInExpr(var, expr) = sigma;
}

// Propagate variables through return statements.
rule {
  if ConsStmtListNode(stmts, head, _);
  if ReturnStmtNode(head, expr);
  if sigma = VarTypeInStmts(var, stmts);
  then VarTypeInExpr(var, expr) = sigma;
}

// ### Propagating variables through expressions

// Propagate variables through equality expressions.
rule {
  if EqualsExprNode(expr, lhs, rhs);
  if sigma = VarTypeInExpr(var, expr);
  then VarTypeInExpr(var, lhs) = sigma;
  then VarTypeInExpr(var, rhs) = sigma;
}

// Propagate variables through function application expressions.
rule {
  if AppExprNode(expr, func_node, args);
  if sigma = VarTypeInExpr(var, expr);
  then VarTypeInExpr(var, func_node) = sigma;
  then VarTypeInExprs(var, args) = sigma;
}

// Propagate variables through function expression.
rule {
  if FunctionExprNode(expr, func_node);
  if sigma = VarTypeInExpr(var, expr);
  then VarTypeInFunction(var, func_node) = sigma;
}

// # Expression typing.
//
// Declared earlier:
//
//   Func ExprType : ExprNode -> Type;
//   Func ExprTypes : ExprListNode -> TypeList;

// The instances associated to expressions with PolyTypes that must be instantiated into
// MonoTypes.
func ExprInstantiation(ExprNode) -> Instantiation;

// Both ExprType and ExprTypes are total. Our axioms enforce that ExprTypes is given by mapping
// ExprType on each ExprNode element.

rule {
  if NilExprListNode(exprs);
  if ntl = NilTypeList();
  then ExprTypes(exprs) = ntl;
}
rule {
  if ConsExprListNode(exprs, head, tail);
  if tys = ExprTypes(exprs);
  if head_ty = ExprType(head);
  if tail_tys = ExprTypes(tail);
  then ConsTypeList(head_ty, tail_tys) = tys;
}

// ## Typing constraints from usage of expressions in statements.
rule {
  if IfStmtNode(_, cond, _, _);
  if et = ExprType(cond);
  then et = BooleanType();
}
rule {
  if WhileStmtNode(_, cond, _);
  if et = ExprType(cond);
  then et = BooleanType();
}

// ## Typing constraints of expression from usages in other expression.
rule {
  if VariableExprNode(expr, var);
  if VarTypeInExpr(var, expr) = MonoType(sigma);
  then ExprType(expr) = sigma;
}

rule {
  if VariableExprNode(expr, var);
  if VarTypeInExpr(var, expr) = PolyType(_);
  then ExprInstantiation(expr)!;
}
rule {
  if VariableExprNode(expr, var);
  if VarTypeInExpr(var, expr) = PolyType(_);
  if instance = ExprInstantiation(expr);
  if ctx = ExprTypeContext(expr);
  then InstantiationTarget(instance) = ctx;
}
rule {
  if VariableExprNode(expr, var);
  if VarTypeInExpr(var, expr) = PolyType(sigma);
  if instance = ExprInstantiation(expr);
  if expr_ty = ExprType(expr);
  then Instantiate(instance, sigma) = expr_ty;
}

rule {
  if VoidExprNode(expr);
  if et = ExprType(expr);
  then et = VoidType();
}
rule {
  if FalseExprNode(expr);
  if et = ExprType(expr);
  then et = BooleanType();
}
rule {
  if TrueExprNode(expr);
  if et = ExprType(expr);
  then et = BooleanType();
}
rule {
  if StringLiteralExprNode(expr, _);
  if et = ExprType(expr);
  then et = StringType();
}
rule {
  if NumberLiteralExprNode(expr, _);
  if et = ExprType(expr);
  then et = NumberType();
}

rule {
  if EqualsExprNode(eq, lhs, rhs);
  if eq_type = ExprType(eq);
  if lhs_type = ExprType(lhs);
  if rhs_type = ExprType(rhs);
  then eq_type = BooleanType();
  then lhs_type = rhs_type;
}
  

// The conclusions of these axioms assert that DomainTypes or CodomainType are defined on some
// types tau. By the axioms relating these functions to FunctionType, this means that such types
// tau must be function types.
rule {
  if AppExprNode(expr, func_node, args);
  if res_ty = ExprType(expr);
  if func_ty = ExprType(func_node);
  if arg_tys = ExprTypes(args);
  then arg_tys = DomainTypes(func_ty);
  then res_ty = CodomainType(func_ty);
}

// No need to instantiate the type of a function expression: Since it would be instantiated only
// once anyway, we can directly equate the function node type with the expression type.
rule {
  if FunctionExprNode(expr, func_node);
  if func_ty = FunctionNodeType(func_node);
  then ExprType(expr) = func_ty;
}

// # Type analysis of function definitions
//
// ## Reachability
//
// To detect whether a function has an implicit `return ();` in the end, we need to decide whether
// the execution flow can reach the end of the function. Obviously this is undecidable in the
// general case. Our type system will thus consider all possible paths through branches of function
// body possible independently of which values expressions can assume. For example, in the function
// 
//   function foo () {
//     if (true) {
//       ...
//     } else {
//       ...
//     }
//   }
//
// we will consider the `else` branch potentially reachable.

// CanProceedStmt(stmt) is true if execution can flow past this statement. CanProceedStmts(stmts)
// is true if CanProceed holds for all statements in stmts.
pred CanProceedStmt(StmtNode);
pred CanProceedStmts(StmtListNode);

rule {
  if NilStmtListNode(stmts);
  then CanProceedStmts(stmts);
}
rule {
  if ConsStmtListNode(stmts, head, tail);
  if CanProceedStmt(head);
  if CanProceedStmts(tail);
  then CanProceedStmts(stmts);
}

rule {
  if ExprStmtNode(stmt, _);
  then CanProceedStmt(stmt);
}
rule {
  if LetStmtNode(stmt, _, _, _);
  then CanProceedStmt(stmt);
}
// ReturnStmtNode does not proceed.
// ReturnVoidStmtNode does not proceed.
rule {
  if FunctionStmtNode(stmt, _);
  then CanProceedStmt(stmt);
}
// An IfStmtNode can proceed if at least one of the two branches can proceed.
rule {
  if IfStmtNode(stmt, _, true_branch, _);
  if CanProceedStmts(true_branch);
  then CanProceedStmt(stmt);
}
rule {
  if IfStmtNode(stmt, _, _, false_branch);
  if CanProceedStmts(false_branch);
  then CanProceedStmt(stmt);
}
rule {
  if WhileStmtNode(stmt, _, _);
  then CanProceedStmt(stmt);
}

// ## Explicit return type analysis
//
// Here we analyze which types the expression in explicit return statements among a list of
// statements have. The list of statements need not be the full body of a function, so we only care
// about explicit returns, not the possible implicit `return ();` at the end of a function.
// However, every list of statements can at most return expressions of a single type, so we can
// model `ReturnsType` as a partial function.
func ReturnsType(StmtListNode) -> Type;

// If there is any suffix of a statement list that can return a given type, then the full list can
// return that type.
rule {
  if ConsStmtListNode(stmts, _, tail);
  if rt = ReturnsType(tail);
  then rt = ReturnsType(stmts);
}

// Base cases for return statements with and without (i.e. void) expressions.
rule {
  if ConsStmtListNode(stmts, head, _);
  if ReturnStmtNode(head, return_value);
  if et = ExprType(return_value);
  then ReturnsType(stmts) = et;
}

rule {
  if ReturnVoidStmtNode(_);
  then VoidType()!;
}
rule {
  if ConsStmtListNode(stmts, head, _);
  if ReturnVoidStmtNode(head);
  if vt = VoidType();
  then ReturnsType(stmts) = vt;
}

// An if statement can return a type if at least one of its two branches returns that type.
rule {
  if ConsStmtListNode(stmts, head, _);
  if IfStmtNode(head, _, true_branch, _);
  if rt = ReturnsType(true_branch);
  then ReturnsType(stmts) = rt;
}
rule {
  if ConsStmtListNode(stmts, head, _);
  if IfStmtNode(head, _, _, false_branch);
  if rt = ReturnsType(false_branch);
  then ReturnsType(stmts) = rt;
}

// A while statement can return a type if its body can return that type.
rule {
  if ConsStmtListNode(stmts, head, _);
  if WhileStmtNode(head, _, body);
  if rt = ReturnsType(body);
  then ReturnsType(stmts) = rt;
}

// ## Tying it together.

// Declared earlier:
// FunctionNodeType : FunctionNode -> Type

// FunctionNodeType is always a function type.
rule {
  if ft = FunctionNodeType(_);
  then DomainTypes(ft)!;
  then CodomainType(ft)!;
}

// Typing constraints due to the types of function variables. Note that the types of argument
// variables as given by VarInArgListNode were previously unified with the optional type annotation (an
// opaque Type element if no annotation was given), which in turn were unified with the types
// appearing in SemanticArgTypes.
rule {
  if Function(func_node, _, args, _, _);
  if dom = DomainTypes(FunctionNodeType(func_node));
  then SemanticArgTypes(args) = dom;
}

// Typing constraints due to an explicit codomain annotation.
rule {
  if Function(func_node, _, _, cod, _);
  if ft = FunctionNodeType(func_node);
  if sot = SemanticOptType(cod);
  then CodomainType(ft) = sot;
}

// Typing constraints due to explicit return statements.
rule {
  if Function(func_node, _, _, _, body);
  if ft = FunctionNodeType(func_node);
  if rt = ReturnsType(body);
  then rt = CodomainType(ft);
}

// An implicit Void return type in case we cannot infer that the function body must
// always reach an explicit return statement.
rule {
  if Function(func_node, _, _, _, body);
  if CanProceedStmts(body);
  if cod = CodomainType(FunctionNodeType(func_node));
  then cod = VoidType();
}
