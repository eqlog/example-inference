Pred Absurd: ();

// # The AST, encoded algebraically/relationally.
Sort TypeNode;
Sort TypeNodeOpt;

Sort ExprNode;
Sort ExprNodeList;

Sort StmtNode;
Sort StmtNodeList;

Sort FunctionNode;

Sort Var;
Sort StringLiteral;
Sort NumberLiteral;

Sort ArgList;

Pred VoidTypeNode : TypeNode;
Pred BooleanTypeNode : TypeNode;
Pred NumberTypeNode : TypeNode;
Pred StringTypeNode : TypeNode;
// FunctionTypeNode(node, domain, codomain)
Pred FunctionTypeNode : TypeNode * ArgList * TypeNode;

Pred VariableExprNode : ExprNode * Var;
Pred VoidExprNode : ExprNode;
Pred FalseExprNode : ExprNode;
Pred TrueExprNode : ExprNode;
Pred StringLiteralExprNode : ExprNode * StringLiteral;
Pred NumberLiteralExprNode : ExprNode * NumberLiteral;
// AppExprNode(node, func, args)
Pred AppExprNode : ExprNode * ExprNode * ExprNodeList;
Pred FunctionExprNode : ExprNode * FunctionNode;

Pred ExprStmtNode : StmtNode * ExprNode;
// LetStmtNode(node, var, initial_value)
Pred LetStmtNode : StmtNode * Var * ExprNode;
// ReturnStmtNode(node, return_value)
Pred ReturnStmtNode : StmtNode * ExprNode;
Pred ReturnVoidStmtNode : StmtNode;
Pred FunctionStmtNode : StmtNode * FunctionNode;
// IfStmtNode(node, condition, true_branch, false_branch)
Pred IfStmtNode : StmtNode * ExprNode * StmtNodeList * StmtNodeList;
// WhileStmtNode(node, condition, body)
Pred WhileStmtNode : StmtNode * ExprNode * StmtNodeList;

// Function(node, function_name, domain, codomain, body)
Pred Function : FunctionNode * Var * ArgList * TypeNodeOpt * StmtNodeList;

// ## <Sort>NodeList operators.
Pred NilExprNodeList : ExprNodeList;
Func ConsExprNodeList : ExprNode * ExprNodeList -> ExprNodeList;

Pred NilStmtNodeList : StmtNodeList;
Func ConsStmtNodeList : StmtNode * StmtNodeList -> StmtNodeList;

// ## TypeNodeOpt operators.
Func NoneTypeNodeOpt : TypeNodeOpt;
Func SomeTypeNodeOpt : TypeNode -> TypeNodeOpt;

// ## ArgList operators.
Pred NilArgList : ArgList;
Func ConsArgList : Var * TypeNodeOpt * ArgList -> ArgList;


// # Semantic types.
Sort Type;
Sort TypeList;

// ## Semantic type operators.
Func VoidType : Type;
Func BooleanType : Type;
Func NumberType : Type;
Func StringType : Type;
// FunctionType(node, domain, codomain)
Func FunctionType : TypeList * Type -> Type;
// Inverses to FunctionType:
// - DomainTypes(FunctionType(domain, _)) = domain
// - CodomainType(FunctionType(_, codomain)) = codomain
Func DomainTypes : Type -> TypeList;
Func CodomainType : Type -> Type;

Axiom DomainTypes(tau)! => CodomainType(tau)!;
Axiom CodomainType(tau)! => DomainTypes(tau)!;
Axiom DomainTypes(FunctionType(domain, _)) ~> domain;
Axiom CodomainType(FunctionType(_, codomain)) ~> codomain;
Axiom FunctionType(DomainTypes(tau), CodomainType(tau)) ~> tau;

// ## TypeList operators.
// We're equating TypeList elements sometimes. In well-typed programs, this is only possible if the
// type lists have the same length and are made up of the same Types.
Func NilTypeList : TypeList;
Func ConsTypeList : Type * TypeList -> TypeList;
Axiom NilTypeList() = ConsTypeList(_, _) => Absurd();
Axiom ConsTypeList(head_0, tail_0) = ConsTypeList(head_1, tail_1) => head_0 = head_1 & tail_0 = tail_1;

// ## Joint injectivity of type operators.
Axiom VoidType() = BooleanType() => Absurd();
Axiom VoidType() = NumberType() => Absurd();
Axiom VoidType() = StringType() => Absurd();
Axiom VoidType() = FunctionType(_, _) => Absurd();

Axiom BooleanType() = NumberType() => Absurd();
Axiom BooleanType() = StringType() => Absurd();
Axiom BooleanType() = FunctionType(_, _) => Absurd();

Axiom NumberType() = StringType() => Absurd();
Axiom NumberType() = FunctionType(_, _) => Absurd();

Axiom StringType() = FunctionType(_, _) => Absurd();

Axiom
    FunctionType(domain_0, codomain_0) = FunctionType(domain_1, codomain_1)
    =>
    domain_0 = domain_1
    & codomain_0 = codomain_1
    ;

// ## Functions assigning to node elements their corresponding semantic Type elements.
Func SemanticType : TypeNode -> Type;
Func SemanticTypeOpt : TypeNodeOpt -> Type;
Func SemanticArgTypes : ArgList -> TypeList;

Axiom VoidTypeNode(tn) => VoidType()! & SemanticType(tn) = VoidType();
Axiom BooleanTypeNode(tn) => BooleanType()! & SemanticType(tn) = BooleanType();
Axiom NumberTypeNode(tn) => NumberType()! & SemanticType(tn) = NumberType();
Axiom StringTypeNode(tn) => StringType()! & SemanticType(tn) = StringType();
Axiom
    FunctionTypeNode(tn, args, codomain)
    & domain_types = SemanticArgTypes(args)
    & codomain_type = SemanticType(codomain)
    =>
    FunctionType(domain_types, codomain_type)!
    & SemanticType(tn) = FunctionType(domain_types, codomain_type);

// SemanticTypeOpt is always defined, but only for SomeTypeNodeOpt elements do they have a
// determined type.
Axiom tno : TypeNodeOpt => SemanticTypeOpt(tno)!;
Axiom SemanticTypeOpt(SomeTypeNodeOpt(tn)) ~> SemanticType(tn);

Axiom NilArgList(al) => NilTypeList()! & SemanticArgTypes(al) = NilTypeList();
Axiom
    al = ConsArgList(_, head, tail)
    & head_type = SemanticTypeOpt(head)
    & tail_types = SemanticArgTypes(tail)
    =>
    ConsTypeList(head_type, tail_types)!
    & SemanticArgTypes(al) = ConsTypeList(head_type, tail_types)
    ;

// # Variable resolution.
//
// VarTypeInStmt(var, stmt) is defined iff `var` is in scope before `stmt` (so not for a `let`
// statement introducing the variable), and similarly for the other functions.
Func VarTypeInStmts : Var * StmtNodeList -> Type;
Func VarTypeInArgList : Var * ArgList -> Type;
Func VarTypeInExpr : Var * ExprNode -> Type;
Func VarTypeInExprs : Var * ExprNodeList -> Type;

// If a variable is in scope for some statement `head`, then also for all statements `tail` after
// it statement.
Axiom VarTypeInStmts(var, ConsStmtNodeList(_, tail)) = sigma => VarTypeInStmts(var, tail) = sigma;

// A variable is in scope after a `let` statement introducing the variable.
Axiom ConsStmtNodeList(head, tail)! & LetStmtNode(head, var, _) => VarTypeInStmts(var, tail)!;
// It is an error if a variable is already in scope for a `let` statement that introduces the
// variable.
Axiom LetStmtNode(head, var, _) & VarTypeInStmts(var, ConsStmtNodeList(head, _))! => Absurd();

// Same as the previous two axioms concerning `LetStmtNode` and `VarTypeInStmts`, but for
// `FunctionStmtNode`.
Axiom
    ConsStmtNodeList(head, tail)!
    & FunctionStmtNode(head, func)
    & Function(func, var, _, _ ,_)
    =>
    VarTypeInStmts(var, tail)!
    ;
Axiom
    FunctionStmtNode(head, func)
    & Function(func, var, _, _ ,_)
    & VarTypeInStmts(var, ConsStmtNodeList(head, _))!
    =>
    Absurd()
    ;

// `VarTypeInArgList` behaves similarly to `VarTypeInStmts` for a list of `let` statements.
Axiom VarTypeInArgList(var, ConsArgList(_, _, tail)) = sigma => VarTypeInArgList(var, tail) = sigma;
Axiom VarTypeInArgList(var, ConsArgList(var, opt_type_node, tail))! => VarTypeInArgList(var, tail) ~> SemanticTypeOpt(opt_type_node);

// An argument of a function is in scope of the body of the function.
Axiom Function(_, _, args, _, body) & VarTypeInArgList(var, args) = sigma => VarTypeInStmts(var, body) = sigma;

// If a variable is in scope in the statement that defines a function, then the variable is also in
// scope in the function.
Axiom
    stmts = ConsStmtNodeList(head, _)
    & FunctionStmtNode(head, func)
    & Function(func, _, _, _ ,body)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInStmts(var, body) = sigma
    ;

// Variables are in scope in the two branches of an if statement.
Axiom
    stmts = ConsStmtNodeList(head, _)
    & IfStmtNode(head, _, true_branch, false_branch)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInStmts(var, true_branch) = sigma
    & VarTypeInStmts(var, false_branch) = sigma
    ;

// Variables are in scope in the body of a while statement.
Axiom
    stmts = ConsStmtNodeList(head, _)
    & WhileStmtNode(head, _, body)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInStmts(var, body) = sigma
    ;

// Propagate variables into expressions occuring in statements.
Axiom
    stmts = ConsStmtNodeList(head, _)
    & ExprStmtNode(head, expr)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInExpr(var, expr) = sigma
    ;
Axiom
    stmts = ConsStmtNodeList(head, _)
    & LetStmtNode(head, _, expr)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInExpr(var, expr) = sigma
    ;
Axiom
    stmts = ConsStmtNodeList(head, _)
    & ReturnStmtNode(head, expr)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInExpr(var, expr) = sigma
    ;
Axiom
    stmts = ConsStmtNodeList(head, _)
    & IfStmtNode(head, cond, _, _)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInExpr(var, cond) = sigma
    ;
Axiom
    stmts = ConsStmtNodeList(head, _)
    & WhileStmtNode(head, cond, _)
    & VarTypeInStmts(var, stmts) = sigma
    =>
    VarTypeInExpr(var, cond) = sigma
    ;

// Propagate variable bindings through expressions.
Axiom
    VarTypeInExprs(var, ConsExprNodeList(head, tail)) = sigma
    => 
    VarTypeInExpr(var, head) = sigma
    & VarTypeInExprs(var, tail) = sigma
    ;
Axiom
    AppExprNode(expr, func, args)
    & VarTypeInExpr(var, expr) = sigma
    => 
    VarTypeInExpr(var, func) = sigma
    & VarTypeInExprs(var, args) = sigma
    ;
Axiom
    FunctionExprNode(expr, func)
    & Function(func, _, _, _ ,body)
    & VarTypeInExpr(var, expr) = sigma
    => 
    VarTypeInStmts(var, body) = sigma
    ;

// # Expression typing.
Func ExprType : ExprNode -> Type;
Func ExprTypes : ExprNodeList -> TypeList;

// Both ExprType and ExprTypes are total. For ExprType we explicitly enforce totality. For
// ExprTypes, this follows inductively from totality of ExprType by the following axioms.
Axiom expr: ExprNode => ExprType(expr)!;
Axiom NilExprNodeList(exprs) => NilTypeList()! & ExprTypes(exprs) = NilTypeList();
Axiom
    exprs = ConsExprNodeList(head, tail)
    & head_type = ExprType(head)
    & tail_types = ExprTypes(tail)
    =>
    ExprTypes(exprs)!
    & ConsTypeList(head_type, tail_types) = ExprTypes(exprs)
    ;

// ## Typing constraints from usage of expressions in statements.
Axiom IfStmtNode(_, cond, _, _) => BooleanType() ~> ExprType(cond);
Axiom WhileStmtNode(_, cond, _) => BooleanType() ~> ExprType(cond);

// ## Typing constraints of expression from usages in other expression.
Axiom VariableExprNode(expr, var) & VarTypeInExpr(var, expr) = sigma => ExprType(expr) = sigma;
Axiom VoidExprNode(expr) => VoidType() ~> ExprType(expr);
Axiom FalseExprNode(expr) => BooleanType() ~> ExprType(expr);
Axiom TrueExprNode(expr) => BooleanType() ~> ExprType(expr);
Axiom StringLiteralExprNode(expr, _) => StringType() ~> ExprType(expr);
Axiom NumberLiteralExprNode(expr, _) => NumberType() ~> ExprType(expr);
Axiom AppExprNode(expr, func, _) => CodomainType(ExprType(func)) ~> ExprType(expr);
Axiom AppExprNode(_, func, args) => DomainTypes(ExprType(func)) ~> ExprTypes(args);
// FunctionExprNodes are handled later, after we've defined some analyses of function bodies.

// ## Analysis of function bodies:
// - Can control flow reach past a given list of statement nodes? This is relevant for whether
//   there is an implicit `return ();` statement at the end of a function.
// - What are the types of the values a given list of statements can return? We only include
//   explicit return statements here, not implicit return statement at the end of a function.
Pred CanProceedStmt : StmtNode;
Pred CanProceedStmts : StmtNodeList;

Axiom NilStmtNodeList(stmts) => CanProceedStmts(stmts);
Axiom
    stmts = ConsStmtNodeList(head, tail)
    & CanProceedStmt(head)
    & CanProceedStmts(tail)
    => 
    CanProceedStmts(stmts);

Axiom ExprStmtNode(stmt, _) => CanProceedStmt(stmt);
Axiom LetStmtNode(stmt, _, _) => CanProceedStmt(stmt);
// ReturnStmtNode does not proceed.
// ReturnVoidStmtNode does not proceed.
Axiom FunctionStmtNode(stmt, _) => CanProceedStmt(stmt);
// An IfStmtNode can proceed if at least one of the two branches can proceed.
Axiom IfStmtNode(stmt, _, true_branch, _) & CanProceedStmts(true_branch) => CanProceedStmt(stmt);
Axiom IfStmtNode(stmt, _, _, false_branch) & CanProceedStmts(false_branch) => CanProceedStmt(stmt);
Axiom WhileStmtNode(stmt, _, _) => CanProceedStmt(stmt);

Func ReturnsType : StmtNodeList -> Type;
Axiom stmts = ConsStmtNodeList(_, tail) => ReturnsType(stmts) ~> ReturnsType(tail);
Axiom
    stmts = ConsStmtNodeList(head, _)
    & ReturnStmtNode(head, return_value)
    =>
    ReturnsType(stmts) ~> ExprType(return_value)
    ;
Axiom
    stmts = ConsStmtNodeList(head, _)
    & IfStmtNode(head, _, true_branch, _)
    =>
    ReturnsType(stmts) ~> ReturnsType(true_branch)
    ;
Axiom
    stmts = ConsStmtNodeList(head, _)
    & IfStmtNode(head, _, _, false_branch)
    =>
    ReturnsType(stmts) ~> ReturnsType(false_branch)
    ;
Axiom
    stmts = ConsStmtNodeList(head, _)
    & WhileStmtNode(head, _, body)
    =>
    ReturnsType(stmts) ~> ReturnsType(body)
    ;

Axiom
    stmts = ConsStmtNodeList(head, _)
    & ReturnVoidStmtNode(head)
    =>
    VoidType()!
    & ReturnsType(stmts) = VoidType();

// ## Typing constraints from function definitions.
Func FunctionNodeType : FunctionNode -> Type;
Axiom
    func: FunctionNode
    =>
    FunctionNodeType(func)!
    & DomainTypes(FunctionNodeType(func))!
    & CodomainType(FunctionNodeType(func))!
    ;
Axiom FunctionExprNode(expr, func) => FunctionNodeType(func) ~> ExprType(expr);
 
// Typing constraints due to an explicit codomain annotation.
Axiom
    Function(func, _, _, codomain, _)
    =>
    CodomainType(FunctionNodeType(func)) ~> SemanticTypeOpt(codomain)
    ;

// Typing constraints due to explicit domain variable types.
Axiom
    Function(func, _, args, _, _)
    =>
    DomainTypes(FunctionNodeType(func)) ~> SemanticArgTypes(args)
    ;

// Typing constraints due to explicit return statements.
Axiom
    Function(func, _, _, _, body)
    =>
    CodomainType(FunctionNodeType(func)) ~> ReturnsType(body)
    ;

// An implicit Void return type in case we cannot infer that the function body must
// always reach an explicit return statement.
Axiom
    Function(func, _, _, _, body)
    & CanProceedStmts(body)
    =>
    VoidType() ~> CodomainType(FunctionNodeType(func))
    ;
