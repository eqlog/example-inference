Sort Ty;
Sort Var;
Sort Expr;
Sort Stmt;

Sort TyList;
Func NilTyList : TyList;
Func ConsTyList : Ty * TyList -> TyList;

Sort VarList;
Func NilVarList : VarList;
Func ConsVarList : Var * VarList -> VarList;

Sort ExprList;
Func NilExprList : ExprList;
Func ConsExprList : Expr * ExprList -> ExprList;

Sort StmtList;
Func NilStmtList : StmtList;
Func ConsStmtList : Stmt * StmtList -> StmtList;

Sort Function;

Func FunctionDef: VarList * StmtList -> Function;

Func ExprTy : Expr -> Ty;
Func ExprsTys: ExprList -> TyList;

// Populated iff a term has contradictory types.
Pred Conflict: ();

Func VoidTy: Ty;
Func BooleanTy: Ty;
Func NumberTy: Ty;
Func StringTy: Ty;
Func ProductTy: TyList -> Ty;
Func FunctionTy: TyList * Ty -> Ty;
// Domain and codomain of function types. Jointly inverse to `FunctionTy`.
Func Domain: Ty -> TyList;
Func Codomain: Ty -> Ty;

Func VariableExpr: Var -> Expr;
Func VariablesExprs: VarList -> ExprList;
Func VoidExpr: Expr;
Func FalseExpr: Expr;
Func TrueExpr: Expr;
Func StringLiteral: Expr;
Func NumberLiteral: Expr;
Func Tuple: ExprList -> Expr;
Func App: Expr * ExprList -> Expr;
Func FunctionExpr: Function -> Expr;

Func ExprStmt: Expr -> Stmt;
Func LetStmt: Var * Expr -> Stmt;
Func ReturnStmt: Expr -> Stmt;
Func ReturnVoidStmt: Stmt;
Func FunctionStmt: Var * Function -> Stmt;
Func DeclStmt: Var * Ty -> Stmt;
Func IfStmt: Expr * StmtList * StmtList -> Stmt;
Func WhileStmt: Expr * StmtList -> Stmt;

Pred CanReturnTy: StmtList * Ty;
Pred CanProceedStmt: Stmt;
Pred CanProceedStmts: StmtList;

Axiom e: Expr => ExprTy(e)!;
Axiom v: Var => VariableExpr(v)!;
Axiom Domain(kappa)! => Codomain(kappa)!;
Axiom Codomain(kappa)! => Domain(kappa)!;
Axiom FunctionTy(Domain(kappa), Codomain(kappa)) ~> kappa;
Axiom Domain(FunctionTy(sigmas, _)) ~> sigmas;
Axiom Codomain(FunctionTy(_, tau)) ~> tau;

Axiom VoidTy() = BooleanTy() => Conflict();
Axiom VoidTy() = NumberTy() => Conflict();
Axiom VoidTy() = StringTy() => Conflict();
Axiom VoidTy() = ProductTy(_) => Conflict();
Axiom VoidTy() = FunctionTy(_, _) => Conflict();

Axiom BooleanTy() = NumberTy() => Conflict();
Axiom BooleanTy() = StringTy() => Conflict();
Axiom BooleanTy() = ProductTy(_) => Conflict();
Axiom BooleanTy() = FunctionTy(_, _) => Conflict();

Axiom NumberTy() = StringTy() => Conflict();
Axiom NumberTy() = ProductTy(_) => Conflict();
Axiom NumberTy() = FunctionTy(_, _) => Conflict();

Axiom StringTy() = ProductTy(_) => Conflict();
Axiom StringTy() = FunctionTy(_, _) => Conflict();

Axiom ProductTy(_) = FunctionTy(_, _) => Conflict();

Axiom es: ExprList => ExprsTys(es)!;
Axiom NilTyList() ~> ExprsTys(NilExprList());
Axiom ConsTyList(ExprTy(head), ExprsTys(tail)) ~> ExprsTys(ConsExprList(head, tail));
Axiom NilTyList() = ConsTyList(_, _) => Conflict();
Axiom ConsTyList(head_0, tail_0) = ConsTyList(head_1, tail_1) => head_0 = head_1 & tail_0 = tail_1;

Axiom vs: VarList => VariablesExprs(vs)!;
Axiom NilExprList() ~> VariablesExprs(NilVarList());
Axiom ConsExprList(VariableExpr(head), VariablesExprs(tail)) ~> VariablesExprs(ConsVarList(head, tail));

Axiom LetStmt(var, init)! => ExprTy(VariableExpr(var)) ~> ExprTy(init);
Axiom FunctionStmt(var, func)! => ExprTy(VariableExpr(var)) ~> ExprTy(FunctionExpr(func));

Axiom func: Function => FunctionExpr(func)!;

Axiom VoidTy() ~> ExprTy(VoidExpr());

Axiom BooleanTy() ~> ExprTy(FalseExpr());
Axiom BooleanTy() ~> ExprTy(TrueExpr());

Axiom StringTy() ~> ExprTy(StringLiteral());

Axiom NumberTy() ~> ExprTy(NumberLiteral());

Axiom ProductTy(ExprsTys(exprs)) ~> ExprTy(Tuple(exprs));

Axiom Codomain(ExprTy(func)) ~> ExprTy(App(func, _));
Axiom App(func, args)! => Domain(ExprTy(func)) ~> ExprsTys(args);

Axiom Domain(ExprTy(FunctionExpr(FunctionDef(arg_vars, _)))) ~> ExprsTys(VariablesExprs(arg_vars));

Axiom stmts = NilStmtList() => CanProceedStmts(stmts);
Axiom stmts = ConsStmtList(head, tail) & CanProceedStmt(head) & CanProceedStmts(tail) => CanProceedStmts(stmts);

Axiom stmt = ExprStmt(_) => CanProceedStmt(stmt);
Axiom stmt = LetStmt(_, _) => CanProceedStmt(stmt);
// ReturnStmt does not proceed.
// ReturnVoidStmt does not proceed.
Axiom stmt = FunctionStmt(_, _) => CanProceedStmt(stmt);
Axiom stmt = DeclStmt(_, _) => CanProceedStmt(stmt);
Axiom stmt = IfStmt(_, true_branch, _) & CanProceedStmts(true_branch)=> CanProceedStmt(stmt);
Axiom stmt = IfStmt(_, _, false_branch) & CanProceedStmts(false_branch) => CanProceedStmt(stmt);
Axiom stmt = WhileStmt(_, _) => CanProceedStmt(stmt);

Axiom stmts = ConsStmtList(_, tail) & CanReturnTy(tail, sigma) => CanReturnTy(stmts, sigma);

Axiom stmts = ConsStmtList(IfStmt(_, true_branch, _), _) & CanReturnTy(true_branch, sigma) => CanReturnTy(stmts, sigma);
Axiom stmts = ConsStmtList(IfStmt(_, _, false_branch), _) & CanReturnTy(false_branch, sigma) => CanReturnTy(stmts, sigma);

Axiom stmts = ConsStmtList(WhileStmt(_, body), _) & CanReturnTy(body, sigma) => CanReturnTy(stmts, sigma);

Axiom stmts = ConsStmtList(ReturnStmt(val), _) & sigma = ExprTy(val) => CanReturnTy(stmts, sigma);
Axiom stmts = ConsStmtList(ReturnVoidStmt(), _) => VoidTy()! & CanReturnTy(stmts, VoidTy());

Axiom CanReturnTy(body, sigma) => Codomain(ExprTy(FunctionExpr(FunctionDef(_, body)))) ~> sigma;
Axiom FunctionDef(_, body)! & CanProceedStmts(body) => VoidTy()!;
Axiom CanProceedStmts(body) => Codomain(ExprTy(FunctionExpr(FunctionDef(_, body)))) ~> VoidTy();
